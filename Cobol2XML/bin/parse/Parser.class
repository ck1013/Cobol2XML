import java.util.{ArrayList, Collections, Enumeration};
import java.lang.{Object, StringBuffer};

/**
 * The Parser class is responsible for parsing a given string of code and
 * converting it into a list of Assembly objects. It uses a top-down parsing
 * approach to match and consume elements in the code.
 */
public class Parser {
    private String name;
    private Assembler assembler;

    /**
     * Constructs a new Parser object with the given name and Assembler.
     *
     * @param name       The name of the parser.
     * @param assembler  The Assembler object to use for assembling the parsed code.
     */
    public Parser(String name, Assembler assembler) {
        this.name = name;
        this.assembler = assembler;
    }

    /**
     * Parses the given code string and converts it into a list of Assembly objects.
     *
     * @param code The code string to parse.
     */
    public void parse(String code) {
        ArrayList<Assembly> pv = new ArrayList<>();
        Signature(pv, code);
        accept(new ParserVisitor() {
            public void visit(Assembly a) {
                pv.add(a);
            }
        }, pv);
        ArrayList<Assembly> al1 = new ArrayList<>();
        ArrayList<Assembly> al2 = new ArrayList<>();
        Enumeration<Assembly> e = Collections.enumeration(pv);
        while (e.hasMoreElements()) {
            Assembly best = null;
            int elementsConsumed = 0;
            while (e.hasMoreElements()) {
                Assembly a = e.nextElement();
                if (a.match(best)) {
                    best = a;
                    elementsConsumed++;
                }
            }
            if (best != null) {
                al1.add(best);
                al2.addAll(elementClone(al2, pv.subList(0, elementsConsumed)));
            }
        }
        assembler.setAssembler(al1);
        System.out.println(al2);
    }

    /**
     * Clones a list of Assembly objects.
     *
     * @param al The list of Assembly objects to clone.
     * @param as The list of Assembly objects to clone from.
     * @return A new list of Assembly objects that is a clone of the given list.
     */
    private ArrayList<Assembly> elementClone(ArrayList<Assembly> al, List<Assembly> as) {
        ArrayList<Assembly> a = new ArrayList<Assembly>();
        for (Assembly b : as) {
            a.add(b.clone());
        }
        return a;
    }

    /**
     * The Signature method is responsible for matching and consuming elements
     * in the code string. It uses a recursive approach to handle nested elements.
     *
     * @param pv  The list of Assembly objects to add matched elements to.
     * @param code The code string to parse.
     */
    private void Signature(ArrayList<Assembly> pv, String code) {
        if (code.length() == 0)
            return;
        ArrayList<Assembly> as = new ArrayList<Assembly>();
        for (int i = 0; i < code.length(); i++) {
            char c = code.charAt(i);
            if (c == '(') {
                int j = i + 1;
                int depth = 1;
                while (depth > 0) {
                    if (j == code.length())
                        throw new RuntimeException("Error in grammar");
                    c = code.charAt(j++);
                    if (c == '(')
                        depth++;
                    else if (c == ')')
                        depth--;
                }
                StringBuffer sb = new StringBuffer();
                for (int k = i + 1; k < j - 1; k++)
                    sb.append(code.charAt(k));
                String s = sb.toString();
                if (s.equals("input")) {
                    as.add(new InputAssembly(i));
                } else if (s.equals("random")) {
                    as.add(new RandomAssembly(i));
                } else {
                    as.add(new NameAssembly(s, i));
                }
                i = j - 1;
            }
        }
        if (as.size() == 1) {
            pv.add(as.get(0));
            as.get(0).workOn(this);
        } else if (as.size() > 1) {
            Assembly best = null;
            for (Assembly a : as) {
                if (best == null)
                    best = a;
                else {
                    if (a.matchBest(best))
                        best = a;
                }
            }
            pv.add(best);
            best.workOn(this);
            ArrayList<Assembly> as2 = new ArrayList<Assembly>();
            for (Assembly a : as) {
                if (!a.match(best))
                    as2.add(a);
            }
            Signature(as2, code.substring(best.getEnd()));
        }
    }

    /**
     * Accepts a ParserVisitor and allows it to visit each Assembly object
     * in the given list.
     *
     * @param pv The ParserVisitor to accept.
     * @param al The list of Assembly objects to visit.
     */
    public void accept(ParserVisitor pv, ArrayList<Assembly> al) {
        pv.visit(al);
    }

    /**
     * The ParserVisitor interface defines a single visit method that is
     * called for each Assembly object in the list.
     */
    public interface ParserVisitor {
        void visit(Assembly a);
    }
}
